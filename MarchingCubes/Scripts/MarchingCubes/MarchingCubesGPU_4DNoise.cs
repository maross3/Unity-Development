using UnityEngine;
using UnityEngine.Rendering;
using System.Collections;
using Photon.Pun;
using UnityEngine.Serialization;
#pragma warning disable 162

using ImprovedPerlinNoiseProject;

namespace MarchingCubesGPUProject
{
    public class MarchingCubesGPU_4DNoise : MonoBehaviour
    {

        //The size of the voxel array for each dimension
        const int N = 80;

        //The size of the buffer that holds the verts.
        //This is the maximum number of verts that the 
        //marching cube can produce, 5 triangles for each voxel.
        const int SIZE = N * N * N * 3 * 5;

        public NetworkManager networkManager;
        public float gain = 0.5f;
        public float frequency = 0.02f;
        public float lacunarity = 2.0f;
        public int seed;
        public float speed = 2.0f;
       
        public Material drawBuffer;
        [FormerlySerializedAs("perlineNoiseShader")] public ComputeShader perlinNoiseShader;
        public ComputeShader marchingCubes;
        public ComputeShader normals;
        public ComputeShader clearBuffer;
        
        public PhotonView photonView;

        private ComputeBuffer _noiseBuffer, _meshBuffer;
        private ComputeBuffer _cubeEdgeFlags, _triangleTable;
        private RenderTexture _normalsBuffer;
        private GPUPerlinNoise _perlinNoise;

        void Start()
        {
            //There are 8 threads run per group so N must be divisible by 8.
            if (N % 8 != 0)
                throw new System.ArgumentException("N must be divisible be 8");

            // holds the voxel values, generated from perlin noise.
            _noiseBuffer = new ComputeBuffer(N * N * N, sizeof(float));

            // RenderTexture holds the normals of the voxels.
            CreateNormalsBuffer();

            //Holds the verts generated by the marching cubes.
            _meshBuffer = new ComputeBuffer(SIZE, sizeof(float) * 7);

            // Represents the edges the triangle will draw from
            _cubeEdgeFlags = new ComputeBuffer(256, sizeof(int));
            _cubeEdgeFlags.SetData(MarchingCubesTables.cubeEdgeFlags);
            
            _triangleTable = new ComputeBuffer(256 * 16, sizeof(int));
            _triangleTable.SetData(MarchingCubesTables.triangleTable);

            //Make the perlin noise, make sure to load resources to match shader used.
            _perlinNoise = new GPUPerlinNoise(seed);
            _perlinNoise.LoadResourcesFor4DNoise();
        }


        private void CreateNormalsBuffer()
        {
            _normalsBuffer = new RenderTexture(N, N, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
            _normalsBuffer.dimension = TextureDimension.Tex3D;
            _normalsBuffer.enableRandomWrite = true;
            _normalsBuffer.useMipMap = false;
            _normalsBuffer.volumeDepth = N;
            _normalsBuffer.Create();
        }

        private void Update()
        {
            if (!photonView.IsMine)
            {
                _noiseBuffer = networkManager._noiseBuffer;
                _meshBuffer = networkManager._meshBuffer;
                ClearBuffer();
                perlinNoiseShader.SetBuffer(0, "_Result", _noiseBuffer);
                AssignVoxelNormals();
                RunMarchingCubes();
                return;
            }
            
            ClearBuffer();
            GeneratePerlinNoise();
            AssignVoxelNormals();
            RunMarchingCubes();
         
            if(PhotonNetwork.IsConnected && PhotonNetwork.CurrentRoom != null)
                networkManager.SynchronizeMesh(_meshBuffer, _noiseBuffer);
        }

        private void RunMarchingCubes()
        {
            //Make the mesh verts
            marchingCubes.SetInt("_Width", N);
            marchingCubes.SetInt("_Height", N);
            marchingCubes.SetInt("_Depth", N);
            marchingCubes.SetInt("_Border", 1);
            marchingCubes.SetFloat("_Target", 0.0f);
            marchingCubes.SetBuffer(0, "_Voxels", _noiseBuffer);
            marchingCubes.SetTexture(0, "_Normals", _normalsBuffer);
            marchingCubes.SetBuffer(0, "_Buffer", _meshBuffer);
            marchingCubes.SetBuffer(0, "_CubeEdgeFlags", _cubeEdgeFlags);
            marchingCubes.SetBuffer(0, "_TriangleConnectionTable", _triangleTable);

            marchingCubes.Dispatch(0, N / 8, N / 8, N / 8);
        }

        private void AssignVoxelNormals()
        {
            //Make the voxel normals.
            normals.SetInt("_Width", N);
            normals.SetInt("_Height", N);
            normals.SetBuffer(0, "_Noise", _noiseBuffer);
            normals.SetTexture(0, "_Result", _normalsBuffer);

            normals.Dispatch(0, N / 8, N / 8, N / 8);
        }
        
        private void GeneratePerlinNoise()
        {
            //Make the voxels.
            perlinNoiseShader.SetInt("_Width", N);
            perlinNoiseShader.SetInt("_Height", N);
            perlinNoiseShader.SetFloat("_Frequency", frequency);
            perlinNoiseShader.SetFloat("_Lacunarity", lacunarity);
            perlinNoiseShader.SetFloat("_Gain", gain);
            perlinNoiseShader.SetFloat("_Time", Time.realtimeSinceStartup * speed);
            perlinNoiseShader.SetTexture(0, "_PermTable1D", _perlinNoise.PermutationTable1D);
            
            // todo, replace perm table with images
            perlinNoiseShader.SetTexture(0, "_PermTable2D", _perlinNoise.PermutationTable2D);
            perlinNoiseShader.SetTexture(0, "_Gradient4D", _perlinNoise.Gradient4D);
            perlinNoiseShader.SetBuffer(0, "_Result", _noiseBuffer);

            perlinNoiseShader.Dispatch(0, N / 8, N / 8, N / 8);
        }

        private void ClearBuffer()
        {
            //Clear the buffer from last frame.
            clearBuffer.SetInt("_Width", N);
            clearBuffer.SetInt("_Height", N);
            clearBuffer.SetInt("_Depth", N);
            clearBuffer.SetBuffer(0, "_Buffer", _meshBuffer);

            clearBuffer.Dispatch(0, N / 8, N / 8, N / 8);
        }

        /// <summary>
        /// Draws the mesh on render calls by setting the buffer and calling DrawProcedural.
        /// </summary>
        private void OnRenderObject()
        {
            //Since mesh is in a buffer need to use DrawProcedual called from OnPostRender or OnRenderObject
            drawBuffer.SetBuffer("_Buffer", _meshBuffer);
            drawBuffer.SetPass(0);

            Graphics.DrawProceduralNow(MeshTopology.Triangles, SIZE);
        }

        private void OnDestroy()
        {
            _noiseBuffer.Release();
            _meshBuffer.Release();
            _cubeEdgeFlags.Release();
            _triangleTable.Release();
            _normalsBuffer.Release();
        }
    }
}





























